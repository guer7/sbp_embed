function [H, HI, D1, D2, DI] = d2_noneq_variable_6(N, h, options)
    % N: Number of grid points
    % h: grid spacing
    % options: struct containing options for constructing the operator
    %          current options are: 
    %               options.stencil_type ('minimal','nonminimal','wide')
    %               options.AD ('upwind', 'op')

    % BP: Number of boundary points
    % order: Accuracy of interior stencil
    BP = 6;
    order = 6;
    if(N<2*BP)
        error(['Operator requires at least ' num2str(2*BP) ' grid points']);
    end

    %%%% Norm matrix %%%%%%%%
    P = zeros(BP, 1);
    P0 = 1.3030223027124e-01;
    P1 = 6.8851501587715e-01;
    P2 = 9.5166202564389e-01;
    P3 = 9.9103890475697e-01;
    P4 = 1.0028757074552e+00;
    P5 = 9.9950151111941e-01;

    for i = 0:BP - 1
        P(i + 1) = eval(['P' num2str(i)]);
    end

    Hv = ones(N, 1);
    Hv(1:BP) = P;
    Hv(end - BP + 1:end) = flip(P);
    Hv = h * Hv;
    H = spdiags(Hv, 0, N, N);
    HI = spdiags(1 ./ Hv, 0, N, N);
    %%%%%%%%%%%%%%%%%%%%%%%%%

    %%%% Q matrix %%%%%%%%%%%

    % interior stencil
    d = [-1/60, 3/20, -3/4, 0, 3/4, -3/20, 1/60];
    d = repmat(d, N, 1);
    Q = spdiags(d, -order / 2:order / 2, N, N);

    % Boundaries
    Q0_0 = -5.0000000000000e-01;
    Q0_1 = 6.6042071945824e-01;
    Q0_2 = -2.2104152954203e-01;
    Q0_3 = 7.6243679810093e-02;
    Q0_4 = -1.7298206716724e-02;
    Q0_5 = 1.6753369904210e-03;
    Q0_6 = 0.0000000000000e+00;
    Q0_7 = 0.0000000000000e+00;
    Q0_8 = 0.0000000000000e+00;
    Q1_0 = -6.6042071945824e-01;
    Q1_1 = 0.0000000000000e+00;
    Q1_2 = 8.7352798702787e-01;
    Q1_3 = -2.6581719253084e-01;
    Q1_4 = 5.7458484948314e-02;
    Q1_5 = -4.7485599871040e-03;
    Q1_6 = 0.0000000000000e+00;
    Q1_7 = 0.0000000000000e+00;
    Q1_8 = 0.0000000000000e+00;
    Q2_0 = 2.2104152954203e-01;
    Q2_1 = -8.7352798702787e-01;
    Q2_2 = 0.0000000000000e+00;
    Q2_3 = 8.1707122038457e-01;
    Q2_4 = -1.8881125503769e-01;
    Q2_5 = 2.4226492138960e-02;
    Q2_6 = 0.0000000000000e+00;
    Q2_7 = 0.0000000000000e+00;
    Q2_8 = 0.0000000000000e+00;
    Q3_0 = -7.6243679810093e-02;
    Q3_1 = 2.6581719253084e-01;
    Q3_2 = -8.1707122038457e-01;
    Q3_3 = 0.0000000000000e+00;
    Q3_4 = 7.6798636652679e-01;
    Q3_5 = -1.5715532552963e-01;
    Q3_6 = 1.6666666666667e-02;
    Q3_7 = 0.0000000000000e+00;
    Q3_8 = 0.0000000000000e+00;
    Q4_0 = 1.7298206716724e-02;
    Q4_1 = -5.7458484948314e-02;
    Q4_2 = 1.8881125503769e-01;
    Q4_3 = -7.6798636652679e-01;
    Q4_4 = 0.0000000000000e+00;
    Q4_5 = 7.5266872305402e-01;
    Q4_6 = -1.5000000000000e-01;
    Q4_7 = 1.6666666666667e-02;
    Q4_8 = 0.0000000000000e+00;
    Q5_0 = -1.6753369904210e-03;
    Q5_1 = 4.7485599871040e-03;
    Q5_2 = -2.4226492138960e-02;
    Q5_3 = 1.5715532552963e-01;
    Q5_4 = -7.5266872305402e-01;
    Q5_5 = 0.0000000000000e+00;
    Q5_6 = 7.5000000000000e-01;
    Q5_7 = -1.5000000000000e-01;
    Q5_8 = 1.6666666666667e-02;

    for i = 1:BP

        for j = 1:BP
            Q(i, j) = eval(['Q' num2str(i - 1) '_' num2str(j - 1)]);
            Q(N + 1 - i, N + 1 - j) = -eval(['Q' num2str(i - 1) '_' num2str(j - 1)]);
        end

    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%% Undivided difference operators %%%%
    % Closed with zeros at the first boundary nodes.
    m = N;

    DD_3 = (-diag(ones(m - 2, 1), -2) + 3 * diag(ones(m - 1, 1), -1) - 3 * diag(ones(m, 1), 0) + diag(ones(m - 1, 1), 1));
    DD_3(1:5, 1:6) = [0 0 0 0 0 0; 0 0 0 0 0 0; -0.46757024540266021836e1 0.88373748766984018738e1 -0.56477423503490435435e1 0.14860699276772438533e1 0 0; 0 -0.13802450758054908946e1 0.36701915175801340778e1 -0.33643068661005748879e1 0.10743604243259317047e1 0; 0 0 -0.10409288946349185618e1 0.30665535320781497878e1 -0.30329117010471766032e1 0.10072870636039453772e1; ];
    DD_3(m - 3:m, m - 5:m) = [-0.10072870636039453772e1 0.30329117010471766032e1 -0.30665535320781497878e1 0.10409288946349185618e1 0 0; 0 -0.10743604243259317047e1 0.33643068661005748879e1 -0.36701915175801340778e1 0.13802450758054908946e1 0; 0 0 -0.14860699276772438533e1 0.56477423503490435435e1 -0.88373748766984018738e1 0.46757024540266021836e1; 0 0 0 0 0 0; ];
    DD_3 = sparse(DD_3);

    DD_4 = (diag(ones(m - 2, 1), 2) - 4 * diag(ones(m - 1, 1), 1) + 6 * diag(ones(m, 1), 0) - 4 * diag(ones(m - 1, 1), -1) + diag(ones(m - 2, 1), -2));
    DD_4(1:5, 1:7) = [0 0 0 0 0 0 0; 0 0 0 0 0 0 0; 0.57302111593550648941e1 -0.12521994384708052700e2 0.11419402572582197931e2 -0.59442797107089754133e1 0.13166603634797652881e1 0 0; 0 0.14441513881249918393e1 -0.49292485821432017638e1 0.67286137322011497757e1 -0.42974416973037268190e1 0.10539251591207869677e1 0; 0 0 0.10466075357769140419e1 -0.40887380427708663837e1 0.60658234020943532065e1 -0.40291482544157815088e1 0.10054553593153806442e1; ];
    DD_4(m - 4:m, m - 6:m) = [0.10054553593153806442e1 -0.40291482544157815088e1 0.60658234020943532065e1 -0.40887380427708663837e1 0.10466075357769140419e1 0 0; 0 0.10539251591207869677e1 -0.42974416973037268190e1 0.67286137322011497757e1 -0.49292485821432017638e1 0.14441513881249918393e1 0; 0 0 0.13166603634797652881e1 -0.59442797107089754133e1 0.11419402572582197931e2 -0.12521994384708052700e2 0.57302111593550648941e1; 0 0 0 0 0 0 0; 0 0 0 0 0 0 0; ];
    DD_4 = sparse(DD_4);

    DD_5 = (-diag(ones(m - 3, 1), -3) + 5 * diag(ones(m - 2, 1), -2) - 10 * diag(ones(m - 1, 1), -1) + 10 * diag(ones(m, 1), 0) - 5 * diag(ones(m - 1, 1), 1) + diag(ones(m - 2, 1), 2));
    DD_5(1:6, 1:8) = [0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0; -0.67194556014531368457e1 0.16377214352871472626e2 -0.19171027475746103125e2 0.14860699276772438533e2 -0.65833018173988264407e1 0.12358712649541552519e1 0 0; 0 -0.14971527633959360324e1 0.61951742553920293904e1 -0.11214356220335249626e2 0.10743604243259317047e2 -0.52696257956039348385e1 0.10423562806837740594e1 0; 0 0 -0.10511702536596915242e1 0.51109225534635829797e1 -0.10109705670157255344e2 0.10072870636039453772e2 -0.50272767965769032212e1 0.10043595308908133377e1; ];
    DD_5(m - 4:m, m - 7:m) = [-0.10043595308908133377e1 0.50272767965769032212e1 -0.10072870636039453772e2 0.10109705670157255344e2 -0.51109225534635829797e1 0.10511702536596915242e1 0 0; 0 -0.10423562806837740594e1 0.52696257956039348385e1 -0.10743604243259317047e2 0.11214356220335249626e2 -0.61951742553920293904e1 0.14971527633959360324e1 0; 0 0 -0.12358712649541552519e1 0.65833018173988264407e1 -0.14860699276772438533e2 0.19171027475746103125e2 -0.16377214352871472626e2 0.67194556014531368457e1; 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0; ];
    DD_5 = sparse(DD_5);

    DD_6 = (diag(ones(m - 3, 1), 3) - 6 * diag(ones(m - 2, 1), 2) + 15 * diag(ones(m - 1, 1), 1) - 20 * diag(ones(m, 1), 0) + 15 * diag(ones(m - 1, 1), -1) - 6 * diag(ones(m - 2, 1), -2) + diag(ones(m - 3, 1), -3));
    DD_6(1:6, 1:9) = [0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0; 0.76591061528436941127e1 -0.20373923615000091397e2 0.28913418478606999359e2 -0.29721398553544877066e2 0.19749905452196479322e2 -0.74152275897249315116e1 0.11881196746227271813e1 0 0; 0 0.15426631885693469226e1 -0.74666187707188589528e1 0.16821534330502874439e2 -0.21487208486518634095e2 0.15808877386811804515e2 -0.62541376841026443562e1 0.10348900354561115264e1 0; 0 0 0.10549863219420430611e1 -0.61331070641562995756e1 0.15164558505235883016e2 -0.20145741272078907544e2 0.15081830389730709664e2 -0.60261571853448800265e1 0.10036303046714514054e1; ];
    DD_6(m - 5:m, m - 8:m) = [0.10036303046714514054e1 -0.60261571853448800265e1 0.15081830389730709664e2 -0.20145741272078907544e2 0.15164558505235883016e2 -0.61331070641562995756e1 0.10549863219420430611e1 0 0; 0 0.10348900354561115264e1 -0.62541376841026443562e1 0.15808877386811804515e2 -0.21487208486518634095e2 0.16821534330502874439e2 -0.74666187707188589528e1 0.15426631885693469226e1 0; 0 0 0.11881196746227271813e1 -0.74152275897249315116e1 0.19749905452196479322e2 -0.29721398553544877066e2 0.28913418478606999359e2 -0.20373923615000091397e2 0.76591061528436941127e1; 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0; 0 0 0 0 0 0 0 0 0; ];
    DD_6 = sparse(DD_6);

    %%%% Difference operators %%%
    D1 = H \ Q;

    % Helper functions for constructing D2(c)
    % TODO: Consider changing sparse(diag(...)) to spdiags(....)
    min_inds = sbp.implementations.d2_sparsity_pattern_inds(m, order, BP, 0, 3);
    nonmin_inds = sbp.implementations.d2_sparsity_pattern_inds(m, order, BP, 1, 3);

    % Minimal 7 point stencil width
    function D2 = D2_fun_minimal(c)
        % Here we add variable diffusion
        C1 = sparse(diag(c));
        C2 = 1/2 * diag(ones(m - 1, 1), -1) + 1/2 * diag(ones(m, 1), 0); C2(1, 2) = 1/2;
        C3 = 1/3 * diag(ones(m - 1, 1), -1) + 1/3 * diag(ones(m - 1, 1), 1) + 1/3 * diag(ones(m, 1), 0); C3(1, 3) = 1/3; C3(m, m - 2) = 1/3;

        C2 = sparse(diag(C2 * c));
        C3 = sparse(diag(C3 * c));

        % Remainder term added to wide second derivative operator
        R = (1/3600 / h) * transpose(DD_6) * C1 * DD_6 + (1/600 / h) * transpose(DD_5) * C2 * DD_5 + (1/80 / h) * transpose(DD_4) * C3 * DD_4;
        D2 = D1 * C1 * D1 - H \ R;

        % Remove potential round off zeros
        D2_tmp = sparse(m,m);
        D2_tmp(min_inds) = D2(min_inds);
        D2 = D2_tmp;
    end

    %  Non-minimal 9 point stencil width
    function D2 = D2_fun_nonminimal(c)
        % Here we add variable diffusion
        C1 = sparse(diag(c));
        C2 = 1/2 * diag(ones(m - 1, 1), -1) + 1/2 * diag(ones(m, 1), 0); C2(1, 2) = 1/2;

        C2 = sparse(diag(C2 * c));

        % Remainder term added to wide second derivative operator
        R = (1/3600 / h) * transpose(DD_6) * C1 * DD_6 + (1/600 / h) * transpose(DD_5) * C2 * DD_5;
        D2 = D1 * C1 * D1 - H \ R;

        % Remove potential round off zeros
        D2_tmp = sparse(m,m);
        D2_tmp(nonmin_inds) = D2(nonmin_inds);
        D2 = D2_tmp;
    end

    % Wide stencil
    function D2 = D2_fun_wide(c)
        % Here we add variable diffusion
        C1 = sparse(diag(c));
        D2 = D1 * C1 * D1;
    end

    switch options.stencil_width
        case 'minimal'
            D2 = @D2_fun_minimal;
        case 'nonminimal'
            D2 = @D2_fun_nonminimal;
        case 'wide'
            D2 = @D2_fun_wide;
        otherwise
            error('No option %s for stencil width', options.stencil_width)
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%%% Artificial dissipation operator %%%
    switch options.AD
        case 'upwind'
            % This is the choice that yield 5th order Upwind
            DI = H \ (transpose(DD_3) * DD_3) * (-1/60);
        case 'op'
            % This choice will preserve the order of the underlying
            % Non-dissipative D1 SBP operator
            DI = H \ (transpose(DD_4) * DD_4) * (-1 / (5 * 60));
            % Notice that you can use any negative number instead of (-1/(5*60))
        otherwise
            error("Artificial dissipation options '%s' not implemented.", option.AD)
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%
end